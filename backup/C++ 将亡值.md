C++中的“将亡值”（xvalue，eXpiring value）是**一种特殊的右值**，指那些生命周期即将结束、资源可以被安全“窃取”的对象。它的核心作用是为移动语义提供判断依据，让编译器知道何时可以触发移动操作（而非拷贝），从而提升性能。


### 一、将亡值的本质：“即将失效的对象”
将亡值的本质是**拥有资源所有权，但马上就要被销毁**的对象。编译器会将满足特定条件的对象标记为将亡值，允许代码通过移动构造函数/移动赋值运算符，直接“接管”它的资源（如内存、文件句柄等），而无需拷贝，避免资源浪费。

简单来说：普通右值（如字面量`10`、临时对象）是“没有名字的临时值”，而将亡值是“有名字，但马上要消失的对象”。


### 二、哪些情况会产生将亡值？
以下是C++中典型的将亡值场景，本质都是“对象即将离开作用域或被销毁”：
1. **返回值为非引用的函数调用**  
   当函数返回一个非引用类型的对象时，该返回对象在被接收前是将亡值。因为它在函数栈帧中创建，函数执行结束后栈帧销毁，这个对象本身即将失效。  
   ```cpp
   struct MyObj { /* 包含资源 */ };
   MyObj createObj() { return MyObj(); } // 返回的MyObj是将亡值
   MyObj obj = createObj(); // 编译器识别到返回值是将亡值，触发移动构造
   ```

2. **转换为右值引用的对象**  
   通过`std::move()`或`static_cast<T&&>()`将左值强制转换为右值引用时，原对象会被标记为将亡值。因为`std::move()`本身不移动资源，只是“告诉编译器：这个对象可以被移动了，它的资源可以被拿走”。  
   ```cpp
   MyObj obj1; // obj1是左值
   MyObj obj2 = std::move(obj1); // std::move(obj1)返回右值引用，obj1成为将亡值
   // 此时obj1的资源已被obj2接管，obj1自身处于“合法但未定义”的状态（不应再使用）
   ```

3. **临时对象的成员访问**  
   当访问临时对象的成员时，该临时对象本身是将亡值。例如：  
   ```cpp
   struct MyObj { int x; };
   int val = MyObj{10}.x; // MyObj{10}是临时对象（将亡值），访问其成员x后，对象立即销毁
   ```


### 三、将亡值的核心作用：触发移动语义
C++引入将亡值的核心目的，是为了**区分“可以被移动的对象”和“不能被移动的对象”**，从而优化性能：
- 对于普通左值（如`MyObj obj;`）：编译器默认认为它还会被使用，只能通过拷贝构造/赋值复制资源，开销大。  
- 对于将亡值（如`std::move(obj)`、函数返回值）：编译器知道它即将失效，允许调用移动构造/赋值，直接“窃取”资源（如指针赋值），开销极小。

举例对比拷贝与移动的差异：  
假设`MyObj`包含一个动态分配的数组（资源）：
- 拷贝构造：需要重新分配一块内存，将原数组数据复制过去，原对象资源保留；  
- 移动构造：直接将原对象的数组指针赋值给新对象，再将原对象的指针置空，无需内存分配和复制，效率极高。  
而将亡值的存在，正是让编译器知道“何时可以用移动替代拷贝”。


### 四、关键注意点：将亡值的“生命周期陷阱”
使用将亡值时必须注意：**被标记为将亡值的对象，其资源可能已被转移，之后不应再访问它的资源**。  
例如：
```cpp
MyObj obj1;
MyObj obj2 = std::move(obj1); // obj1成为将亡值，资源被obj2接管
obj1.doSomething(); // 错误！obj1的资源已被移走，此时调用成员函数可能导致未定义行为（如访问空指针）
```
简单总结：`std::move()`之后，原对象“活着但没了资源”，只能执行“不依赖资源”的操作（如析构），不能再使用其核心功能。
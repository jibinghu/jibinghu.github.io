“每个进程最多能开多少线程”并不是一个固定常数，通常由多重限制共同决定：

用户/进程的任务数限制（把线程也当成 task/process 计数）
线程栈大小占用的虚拟内存
系统级最大线程数 / pid 数
cgroup / 容器的 pids 限制
可映射内存页上限（Linux 的 vm.max_map_count）

``` bash
# 当前 shell 的用户级“最大进程数”（线程也算），影响同一用户下总 task 数
ulimit -u

# 查看某个进程的 RLIMIT（含 Max processes, Max address space 等）
cat /proc/<PID>/limits

# 系统最大线程（task）总数
cat /proc/sys/kernel/threads-max

# 系统可分配的最大 PID（上限影响可创建 task 的数量级）
cat /proc/sys/kernel/pid_max

# cgroup（容器/服务）对 PIDs 的限制（无限为 "max"）
cat /sys/fs/cgroup/pids.max 2>/dev/null || true
```

``` cpp
# 主线程栈软限制（不是 pthread 默认值，但有参考意义）
ulimit -s

# 最小线程栈（pthread 的保底值）
getconf PTHREAD_STACK_MIN

# 可映射内存区域上限（map 数太多也会失败）
cat /proc/sys/vm/max_map_count

# 当前进程的线程数
grep ^Threads: /proc/$$/status

# 物理/可用内存概览（仅用于粗略估算）
grep -E 'MemTotal|MemAvailable' /proc/meminfo
```